     1 <!DOCTYPE html>
     2 <html lang="en">
     3 <head>
     4     <meta charset="UTF-8">
     5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     6     <title>Foam Angel Interactive Model</title>
     7     <style>
     8         body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #1a1a2e; color: #e0e0e0;
       display: flex; }
     9         #controls-panel { width: 280px; padding: 20px; background-color: #16213e; height: 100vh; overflow-y: auto
       box-shadow: 2px 0 5px rgba(0,0,0,0.5); }
    10         #controls-panel h2 { margin-top: 0; color: #0f3460; }
    11         .control-group { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #0f3460; }
    12         .control-group label { display: block; margin-bottom: 8px; font-weight: bold; }
    13         .control-group input[type="range"], .control-group button, .control-group input[type="checkbox"] { width:
       calc(100% - 16px); padding: 8px; margin-bottom: 5px; background-color: #0f3460; color: #e0e0e0; border: 1px solid
       #0f3460; border-radius: 4px; cursor: pointer; }
    14         .control-group input[type="range"] { margin-top: 5px; }
    15         .control-group button { background-color: #e94560; border-color: #e94560; }
    16         .control-group button:hover { background-color: #c43c52; }
    17         .control-group input[type="checkbox"] { width: auto; margin-right: 8px; }
    18         .mode-switch label { font-weight: normal; display: inline-block; margin-right: 15px;}
    19         #explanation { flex-grow: 1; padding: 20px; }
    20         #explanation h3 { color: #e94560; }
    21         canvas { display: block; }
    22         .info-section { margin-bottom: 15px; }
    23         .info-section h4 { color: #0f3460; margin-bottom: 5px; }
    24     </style>
    25 </head>
    26 <body>
    27     <div id="controls-panel">
    28         <h2>Foam Angel Controls</h2>
    29
    30         <div class="control-group">
    31             <label for="rotationSlider">Rotation Speed</label>
    32             <input type="range" id="rotationSlider" min="0" max="2" step="0.1" value="0">
    33             <span id="rotationValue">0</span>
    34             <p style="font-size: 0.8em;">0: Static | 1: Dynamic Symmetry | 2: High-Speed Envelope</p>
    35         </div>
    36
    37         <div class="control-group">
    38             <button id="perturbBtn">Apply Perturbation</button>
    39             <p style="font-size: 0.8em;">Injects a small random disturbance.</p>
    40         </div>
    41
    42         <div class="control-group">
    43             <label>Steering Controls</label>
    44             <div class="steering-toggles">
    45                 <label><input type="checkbox" id="stiffenA"> Stiffen Facet Group A</label><br>
    46                 <label><input type="checkbox" id="stiffenB"> Stiffen Facet Group B</label><br>
    47                 <label><input type="checkbox" id="stiffenC"> Stiffen Facet Group C</label>
    48             </div>
    49             <p style="font-size: 0.8em;">Increases stiffness, shifts tension, changes trajectory.</p>
    50         </div>
    51
    52         <div class="control-group">
    53             <label>Mode Visualization</label>
    54             <div class="mode-switch">
    55                 <label><input type="radio" name="mode" value="stiffness" checked> Stiffness Spectrum</label>
    56                 <label><input type="radio" name="mode" value="tension"> Tension Routing</label><br>
    57                 <label><input type="radio" name="mode" value="eigenvalue"> Eigenvalue Stability</label>
    58                 <label><input type="radio" name="mode" value="envelope"> Dynamic Envelope</label>
    59             </div>
    60         </div>
    61     </div>
    62     <div id="explanation">
    63         <div class="info-section">
    64             <h3>Foam Angel Hyperfoil Model</h3>
    65             <p>Explore the dynamic behavior of the Foam Angel hyperfoil. Interact with its geometry, stiffness, a
       tension routing to understand its unique properties.</p>
    66         </div>
    67         <div class="info-section">
    68             <h4>Visual Layers</h4>
    69             <p><strong>Facet Geometry:</strong> The fundamental 27-facet structure of the hyperfoil.</p>
    70             <p><strong>Stiffness Coloring:</strong> Facet colors visualize stiffness modes â€“ cool colors for low
       modes, warm for high. Observe the exponential ladder gradient.</p>
    71             <p><strong>Tension Routing Lines:</strong> Thin lines indicate tension paths between facets. Thicknes
       represents magnitude, and color suggests direction.</p>
    72             <p><strong>Dynamic Envelope Overlay:</strong> A translucent sphere shows the overall stability and
       shape envelope, tightening as rotation increases.</p>
    73         </div>
    74          <div class="info-section">
    75             <h4>Simulation Behaviors</h4>
    76             <p><strong>Static Mode:</strong> Observe the irregular polyhedron with anisotropic tension and visibl
       facet boundaries.</p>
    77             <p><strong>Dynamic Symmetry Mode:</strong> Facets blur, tension equalizes, and the envelope becomes
       nearly spherical.</p>
    78             <p><strong>Perturbation Response:</strong> Apply a disturbance and watch low-index facets flash as
       tension redistributes, returning the system to equilibrium.</p>
    79             <p><strong>Steering:</strong> Stiffen facet groups to observe tension shifts and how the craft curves
       in the corresponding direction.</p>
    80         </div>
    81     </div>
    82     <canvas id="simulationCanvas"></canvas>
    83
    84     <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    85     <!-- Consider adding math.js or a similar library if full eigenvalue computation is needed -->
    86     <script>
    87         // --- Constants and Global Variables ---
    88         const FACET_COUNT = 27;
    89         let stiffnessValues = new Array(FACET_COUNT).fill(1.0); // Default uniform stiffness.
    90         let couplingMatrix = []; // Will be initialized
    91         let tensionGraph = {};
    92         let rotationSpeed = 0;
    93         let perturbationActive = false;
    94         let groupA_facets = [];
    95         let groupB_facets = [];
    96         let groupC_facets = [];
    97         let mesh;
    98         let scene, camera, renderer;
    99         let facetColors = []; // For storing colors to apply to mesh
   100
   101         // --- Three.js Setup ---
   102         function initThreeJS(canvasId) {
   103             const canvas = document.getElementById(canvasId);
   104             scene = new THREE.Scene();
   105             camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
   106             renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
   107             renderer.setSize(canvas.clientWidth, canvas.clientHeight);
   108             renderer.setPixelRatio(window.devicePixelRatio);
   109
   110             // Ambient light
   111             const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
   112             scene.add(ambientLight);
   113
   114             // Directional light (optional, for better shading)
   115             const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
   116             directionalLight.position.set(5, 5, 5).normalize();
   117             scene.add(directionalLight);
   118
   119             camera.position.z = 5;
   120
   121             // Generate geometry and create mesh
   122             const geometry = generateHyperfoilGeometry();
   123             const material = new THREE.MeshPhongMaterial({ vertexColors: true, side: THREE.DoubleSide });
   124             mesh = new THREE.Mesh(geometry, material);
   125             scene.add(mesh);
   126
   127             // Initial color setup
   128             updateFacetColors(stiffnessValues); // Use initial stiffness as placeholder for eigenvalues
   129         }
   130
   131         // --- Geometry Module (geometry.js conceptual) ---
   132         function generateHyperfoilGeometry() {
   133             const vertices = [];
   134             // Procedural example: Distribute points roughly on a sphere.
   135             // For a real hyperfoil, these coordinates would be precisely defined.
   136             for (let i = 0; i < FACET_COUNT; i++) {
   137                 const theta = Math.acos(1 - 2 * (i + 0.5) / FACET_COUNT);
   138                 const phi = Math.PI * (3 - Math.sqrt(5)) * (i + 0.5); // Golden ratio distribution
   139                 vertices.push(new THREE.Vector3(Math.sin(theta) * Math.cos(phi), Math.sin(theta) * Math.sin(phi),
       Math.cos(theta)));
   140             }
   141
   142             // Define faces. This is a simplified representation.
   143             // A real hyperfoil would have specific adjacency data.
   144             const faces = [];
   145             // Example: Connect nearest neighbors for demonstration. This needs to be precise for your model.
   146             for (let i = 0; i < FACET_COUNT; i++) {
   147                 // Connect i to i+1 (wrapping around) and i+1 to i+2 etc.
   148                 // This is a naive approach; actual triangulation needed.
   149                 if (i < FACET_COUNT - 2) {
   150                     faces.push([i, i + 1, i + 2]);
   151                 } else if (i === FACET_COUNT - 2) {
   152                     faces.push([i, i + 1, 0]);
   153                 } else if (i === FACET_COUNT - 1) {
   154                     faces.push([i, 0, 1]);
   155                 }
   156             }
   157
   158             const geometry = new THREE.BufferGeometry();
   159             // Flatten vertices array for BufferAttribute
   160             const positions = new Float32Array(vertices.length * 3);
   161             for (let i = 0; i < vertices.length; i++) {
   162                 positions[i * 3] = vertices[i].x;
   163                 positions[i * 3 + 1] = vertices[i].y;
   164                 positions[i * 3 + 2] = vertices[i].z;
   165             }
   166             geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
   167
   168             // Flatten faces array for Index attribute
   169             geometry.setIndex(faces.flat());
   170             geometry.computeVertexNormals();
   171             return geometry;
   172         }
   173
   174         function getFacetCenter(index) {
   175             // Returns the position of a facet's node. Assumes 'mesh' is available and geometry is loaded.
   176             const positions = mesh.geometry.attributes.position.array;
   177             const i = index * 3;
   178             return new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
   179         }
   180
   181         // Placeholder for facet adjacency check
   182         function areFacetsAdjacent(i, j) {
   183             // This function must be implemented based on the specific 27-facet geometry.
   184             // For demo, let's assume a simple wrap-around adjacency for a few facets.
   185             if (i === j) return false;
   186             const diff = Math.abs(i - j);
   187             return diff === 1 || diff === FACET_COUNT - 1 || diff === 2 || diff === FACET_COUNT - 2; // Very roug
       adjacency heuristic
   188         }
   189
   190         // --- Stiffness Model Module (stiffnessModel.js conceptual) ---
   191         function initializeStiffnessAndCoupling() {
   192             initCouplingMatrix();
   193             // Assign facets to groups A, B, C (example split)
   194             groupA_facets = [0, 1, 2, 3, 4, 5, 6, 7, 8];
   195             groupB_facets = [9, 10, 11, 12, 13, 14, 15, 16, 17];
   196             groupC_facets = [18, 19, 20, 21, 22, 23, 24, 25, 26];
   197         }
   198
   199         function initCouplingMatrix() {
   200             couplingMatrix = Array.from({ length: FACET_COUNT }, () => new Array(FACET_COUNT).fill(0));
   201             for (let i = 0; i < FACET_COUNT; i++) {
   202                 for (let j = i + 1; j < FACET_COUNT; j++) {
   203                     if (areFacetsAdjacent(i, j)) {
   204                         couplingMatrix[i][j] = couplingMatrix[j][i] = 0.3; // Base coupling strength
   205                     }
   206                 }
   207             }
   208         }
   209
   210         function computeEigenvalues(simplified = true) {
   211             if (simplified) {
   212                 // Approximate: Sum stiffness and coupling for each facet.
   213                 // This is a very basic approximation of mode behavior.
   214                 return stiffnessValues.map((e, i) => e + couplingMatrix[i].reduce((sum, val) => sum + val, 0));
   215             } else {
   216                 // Placeholder for full eigenvalue computation (requires a matrix library like numeric.js or WASM
   217                 console.warn("Full eigenvalue computation not implemented.");
   218                 return stiffnessValues.map((e, i) => e); // Return raw stiffness as fallback
   219             }
   220         }
   221
   222         function stiffenGroup(groupId, amount = 0.3) {
   223             let groupFacets = [];
   224             if (groupId === 'A') groupFacets = groupA_facets;
   225             else if (groupId === 'B') groupFacets = groupB_facets;
   226             else if (groupId === 'C') groupFacets = groupC_facets;
   227
   228             groupFacets.forEach(i => {
   229                 stiffnessValues[i] += amount;
   230                 // Prevent excessively high stiffness values
   231                 if (stiffnessValues[i] > 3.0) stiffnessValues[i] = 3.0;
   232             });
   233         }
   234
   235         function resetStiffness() {
   236              stiffnessValues = new Array(FACET_COUNT).fill(1.0);
   237         }
   238
   239         // --- Tension Routing Module (tensionRouting.js conceptual) ---
   240         function updateTensionRouting() {
   241             tensionGraph = {};
   242             for (let i = 0; i < FACET_COUNT; i++) {
   243                 for (let j = i + 1; j < FACET_COUNT; j++) {
   244                     if (couplingMatrix[i][j] > 0) {
   245                         // Tension based on stiffness difference and coupling
   246                         const tensionMagnitude = Math.abs(stiffnessValues[i] - stiffnessValues[j]) *
       couplingMatrix[i][j] * 5; // Scaled for visualization
   247                         if (tensionMagnitude > 0.1) { // Only draw significant tensions
   248                             tensionGraph[`${i}-${j}`] = {
   249                                 magnitude: tensionMagnitude,
   250                                 direction: stiffnessValues[i] > stiffnessValues[j] ? 'i_to_j' : 'j_to_i'
   251                             };
   252                         }
   253                     }
   254                 }
   255             }
   256         }
   257
   258         // --- Renderer Module (renderer.js conceptual) ---
   259         function updateFacetColors(eigenvalues) {
   260             const minVal = Math.min(...eigenvalues);
   261             const maxVal = Math.max(...eigenvalues);
   262             const colorRange = maxVal - minVal;
   263
   264             // Map eigenvalues to colors (gradient: cool blue to warm red)
   265             facetColors = eigenvalues.map(val => {
   266                 // Normalize value for color mapping
   267                 const normalizedVal = colorRange === 0 ? 0.5 : (val - minVal) / colorRange;
   268                 // Use HSL for smoother gradients: Hue shifts from blue (0.6) to red (0)
   269                 const hue = 0.6 - (normalizedVal * 0.6); // Map 0..1 to 0.6..0
   270                 return new THREE.Color().setHSL(hue, 1.0, 0.5); // Full saturation, mid-lightness
   271             });
   272
   273             const colorsArray = new Float32Array(facetColors.length * 3);
   274             for (let i = 0; i < facetColors.length; i++) {
   275                 colorsArray[i * 3] = facetColors[i].r;
   276                 colorsArray[i * 3 + 1] = facetColors[i].g;
   277                 colorsArray[i * 3 + 2] = facetColors[i].b;
   278             }
   279             mesh.geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
   280         }
   281
   282         function updateTensionLines(scene) {
   283             // Remove previous lines
   284             scene.traverse(function(object) {
   285                 if (object.isLine && object.userData.isTensionLine) {
   286                     scene.remove(object);
   287                 }
   288             });
   289
   290             // Add new tension lines
   291             Object.entries(tensionGraph).forEach(([key, { magnitude, direction }]) => {
   292                 const [i, j] = key.split('-').map(Number);
   293                 const posI = getFacetCenter(i);
   294                 const posJ = getFacetCenter(j);
   295
   296                 const lineGeom = new THREE.BufferGeometry().setFromPoints([posI, posJ]);
   297                 // Adjust linewidth based on magnitude. Max thickness for visibility.
   298                 const maxWidth = 5;
   299                 const material = new THREE.LineBasicMaterial({
   300                     color: direction === 'i_to_j' ? 0xff0000 : 0x00aaff, // Red for i->j, Blue for j->i
   301                     linewidth: Math.max(0.1, magnitude) * maxWidth // Ensure minimum visibility
   302                 });
   303                 const line = new THREE.Line(lineGeom, material);
   304                 line.userData.isTensionLine = true; // Mark for easy removal
   305                 scene.add(line);
   306             });
   307         }
   308
   309         function updateDynamicEnvelope() {
   310             // Placeholder: Add/update a translucent sphere mesh based on rotationSpeed
   311             // For now, this is just a conceptual placeholder.
   312         }
   313
   314         // --- UI Module (ui.js conceptual) ---
   315         let animationFrameId;
   316
   317         function initUIListeners() {
   318             const rotationSlider = document.getElementById('rotationSlider');
   319             const rotationValueDisplay = document.getElementById('rotationValue');
   320             const perturbBtn = document.getElementById('perturbBtn');
   321             const stiffenACheckbox = document.getElementById('stiffenA');
   322             const stiffenBCheckbox = document.getElementById('stiffenB');
   323             const stiffenCCheckbox = document.getElementById('stiffenC');
   324             const modeRadios = document.querySelectorAll('input[name="mode"]');
   325
   326             rotationSlider.addEventListener('input', (e) => {
   327                 rotationSpeed = parseFloat(e.target.value);
   328                 rotationValueDisplay.textContent = rotationSpeed.toFixed(1);
   329                 updateDynamicEnvelope(); // Update envelope based on speed
   330             });
   331
   332             perturbBtn.addEventListener('click', () => {
   333                 applyPerturbation();
   334                 // Visual feedback for perturbation (e.g., brief color flash)
   335                 animateRippleEffect();
   336             });
   337
   338             stiffenACheckbox.addEventListener('change', (e) => { if (e.target.checked) stiffenGroup('A'); else
       resetStiffness(); updateState(); });
   339             stiffenBCheckbox.addEventListener('change', (e) => { if (e.target.checked) stiffenGroup('B'); else
       resetStiffness(); updateState(); });
   340             stiffenCCheckbox.addEventListener('change', (e) => { if (e.target.checked) stiffenGroup('C'); else
       resetStiffness(); updateState(); });
   341
   342             modeRadios.forEach(radio => {
   343                 radio.addEventListener('change', () => updateVisualizationMode(radio.value));
   344             });
   345
   346             // Handle window resize
   347             window.addEventListener('resize', onWindowResize, false);
   348         }
   349
   350         function onWindowResize() {
   351             const canvas = document.getElementById('simulationCanvas');
   352             const width = canvas.clientWidth;
   353             const height = canvas.clientHeight;
   354             renderer.setSize(width, height);
   355             camera.aspect = width / height;
   356             camera.updateProjectionMatrix();
   357         }
   358
   359         function applyPerturbation() {
   360             const perturbationAmount = 0.2; // Amount to perturb stiffness
   361             const randomPerturbations = Array.from({ length: FACET_COUNT }, () => (Math.random() - 0.5) *
       perturbationAmount);
   362             stiffnessValues = stiffnessValues.map((val, i) => val + randomPerturbations[i]);
   363             // Clamp values to avoid issues
   364             stiffnessValues = stiffnessValues.map(val => Math.max(0.5, Math.min(3.0, val)));
   365             perturbationActive = true;
   366             // Perturbation effect should stabilize over time
   367             setTimeout(() => { perturbationActive = false; }, 2000);
   368         }
   369
   370         function animateRippleEffect() {
   371             // Simple visual feedback: briefly flash facets
   372             const originalColors = [...mesh.geometry.attributes.color.array]; // Save original colors
   373             const flashColor = new THREE.Color(0xffffff); // White flash
   374             const flashDuration = 300; // ms
   375             const startTime = performance.now();
   376
   377             function flash(currentTime) {
   378                 const elapsedTime = currentTime - startTime;
   379                 let alpha = 1.0 - (elapsedTime / flashDuration);
   380                 if (alpha < 0) alpha = 0;
   381
   382                 // Apply flash color with alpha blending (or just set white temporarily)
   383                 // For simplicity, we'll just set to white for a duration
   384                 const tempColors = new Float32Array(originalColors);
   385                 if (alpha > 0) {
   386                     for (let i = 0; i < tempColors.length; i += 3) {
   387                         tempColors[i] = flashColor.r;
   388                         tempColors[i+1] = flashColor.g;
   389                         tempColors[i+2] = flashColor.b;
   390                     }
   391                     mesh.geometry.setAttribute('color', new THREE.BufferAttribute(tempColors, 3));
   392                     requestAnimationFrame(flash);
   393                 } else {
   394                     // Restore original colors or current calculated colors
   395                     updateFacetColors(stiffnessValues); // Re-apply current calculated colors
   396                 }
   397             }
   398             requestAnimationFrame(flash);
   399         }
   400
   401         // --- Simulation Loop Module (simulation.js conceptual) ---
   402         function updateState() {
   403             updateTensionRouting();
   404             const eigenvalues = computeEigenvalues(); // Using simplified for now
   405             updateFacetColors(eigenvalues);
   406
   407             const currentMode = document.querySelector('input[name="mode"]:checked').value;
   408             updateVisualizationMode(currentMode);
   409         }
   410
   411         function updateVisualizationMode(mode) {
   412             if (mode === 'tension') {
   413                 updateTensionLines(scene);
   414                 // Hide other visual layers if needed, or adjust their visibility
   415             } else {
   416                 // Remove tension lines if not in tension mode
   417                 scene.traverse(function(object) {
   418                     if (object.userData.isTensionLine) {
   419                         scene.remove(object);
   420                     }
   421                 });
   422             }
   423
   424             if (mode === 'envelope') {
   425                 updateDynamicEnvelope();
   426             }
   427             // For 'stiffness' and 'eigenvalue', colors are already updated by updateFacetColors
   428         }
   429
   430         function animate() {
   431             requestAnimationFrame(animate);
   432
   433             // Update mesh rotation based on slider
   434             if (mesh) {
   435                 mesh.rotation.y += rotationSpeed * 0.01;
   436             }
   437
   438             // If perturbation happened, ensure state is updated and stabilized
   439             if (perturbationActive) {
   440                 // Re-apply stiffness/colors if needed, though updateState handles this
   441             }
   442
   443             // Render the scene
   444             renderer.render(scene, camera);
   445         }
   446
   447         // --- Main Initialization ---
   448         function main() {
   449             // Initialize stiffness and coupling matrix
   450             initializeStiffnessAndCoupling();
   451             updateState(); // Initial update to set up colors and tensions
   452
   453             // Initialize Three.js renderer and scene
   454             initThreeJS('simulationCanvas');
   455
   456             // Initialize UI event listeners
   457             initUIListeners();
   458
   459             // Start the animation loop
   460             animate();
   461         }
   462
   463         // Execute main function on page load
   464         window.onload = main;
   465
   466     </script>
   467 </body>
   468 </html>
